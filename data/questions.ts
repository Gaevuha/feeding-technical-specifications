// /data/questions.ts
import { QuestionType, Category, AnswerType } from "@/types/quiz";

/**
 * Fisher–Yates shuffle
 */
function shuffle<T>(arr: T[]): T[] {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

function makeQuestion(
  id: string,
  question: string,
  answers: AnswerType[]
): QuestionType {
  return { id, question, answers: shuffle(answers) };
}

export const questionsByCategory: Record<Category, QuestionType[]> = {
  "html+css": [
    makeQuestion(
      "html-1",
      "Що таке <!DOCTYPE html> і навіщо його вказують? Що станеться, якщо його не написати?",
      [
        {
          text: "DOCTYPE вказує тип поточного документа. Це необхідно, щоб браузер розумів, як слід інтерпретувати поточну веб-сторінку, оскільки HTML існує у кількох версіях. Якщо не вказати то браузер спробує відобразити сторінку в режимі сумісності (quirks mode). Це може призвести до того, що в різних браузерах сторінка відображатиметься по-різному.",
          correct: true,
        },
        { text: "Підключає CSS до сторінки.", correct: false },
        { text: "Визначає кодування сторінки (charset).", correct: false },
        {
          text: "Вказує версію JavaScript, яку потрібно виконувати.",
          correct: false,
        },
      ]
    ),

    makeQuestion(
      "html-2",
      "Навіщо в HTML-документі використовують meta-теги і яку інформацію вони задають?",
      [
        {
          text: "Мета-теги – це теги, які надають пошуковим системам додаткову інформацію про сторінку сайту. Наприклад, механізми пошукових систем звертаються до мета-тегів для отримання опису сайту, ключових слів та інших даних. Мета-теги для сайту розміщуються всередині <head>.",
          correct: true,
        },
        {
          text: "Meta-теги визначають кольори елементів на сторінці.",
          correct: false,
        },
        {
          text: "Meta-теги використовуються для вставки зображень.",
          correct: false,
        },
        { text: "Meta-теги створюють кнопки взаємодії.", correct: false },
      ]
    ),

    makeQuestion(
      "html-3",
      "Чим відрізняються блочні (block) та рядкові (inline) HTML-елементи? Наведіть приклади.",
      [
        {
          text: "Блокові елементи є основою, яка використовується для верстки сторінок. Такий елемент є прямокутником, який за замовчуванням займає всю доступну ширину сторінки, а висота елемента залежить від його вмісту. Такий елемент завжди починається з нового рядка. Блоковий елемент може містити в собі інші блокові та рядкові елементи. Приклади блокових елементів: <div>, <p>, <ul>, <ol>, <h1>   На відміну від блокового, рядковий елемент не переноситься на новий рядок, а розташовується у тому ж рядку, що й попередній елемент. Ширина рядкового елемента залежить від його вмісту. Блокові елементи не можна вкладати в рядкові. Приклади рядкових елементів: <a>, <span>, <strong>, <em>, <img>",
          correct: true,
        },
        {
          text: "Block завжди червоного кольору, inline — синього.",
          correct: false,
        },
        {
          text: "Inline завжди займає всю ширину, block — тільки по контенту.",
          correct: false,
        },
        { text: "Block — це HTML-коментарі, inline — теги.", correct: false },
      ]
    ),

    makeQuestion(
      "html-4",
      "Чому деякі символи на вебсторінці відображаються у вигляді квадратів або знаків питання? Що може бути причиною?",
      [
        {
          text: "Це може виникати через те, що деякі браузери можуть не підтримувати певні символи операційної системи. Також може відрізнятися кодування. Або не підключено потрібний шрифт з іконками.",
          correct: true,
        },
        { text: "Тому що браузер заблокував CSS.", correct: false },
        { text: "Бо HTML-файл завжди пошкоджений.", correct: false },
        { text: "Через некоректний тег <div>.", correct: false },
      ]
    ),

    makeQuestion(
      "html-5",
      "Що таке семантична верстка в HTML і навіщо вона потрібна? Які семантичні теги ви можете назвати?",
      [
        {
          text: "Це верстка орієнтована на структурування html-документів. У ній використовуються теги, які поділяють код на логічні блоки, що явно показують їх роль та зміст у структурі сторінки. Семантична верстка відрізняється від блокової лише елементами, що використовуються при структуризації сторінки. У блоковій верстці використовують в основному тільки елемент div, а в семантичній використовуються крім div ще безліч інших тегів, таких як: header, main, section, footer, nav, aside.",
          correct: true,
        },
        {
          text: "Верстка, що використовує тільки <div> і класи.",
          correct: false,
        },
        {
          text: "Використання тільки інлайн-стилів замість CSS.",
          correct: false,
        },
        {
          text: "Техніка, яка виключає використання заголовків.",
          correct: false,
        },
      ]
    ),

    makeQuestion(
      "html-6",
      "Які типи заголовків існують в HTML і для чого вони використовуються?",
      [
        {
          text: "HTML підтримує шість різних типів заголовків. Ці заголовки відрізняються за розміром шрифту, починаючи з найбільшого. h1 – найбільший заголовок. h6 – найменший заголовок. h1 має бути лише 1 на сторінці.",
          correct: true,
        },
        { text: "Лише h1 і h2 доступні в HTML.", correct: false },
        { text: "header1–header6 — нові HTML-теги.", correct: false },
        {
          text: "title1–title6 — відповідають за SEO і замінюють h-теги.",
          correct: false,
        },
      ]
    ),

    makeQuestion(
      "html-7",
      "Що таке потік документа (document flow) в HTML і CSS? Чи можна на нього впливати — і якщо так, як?",
      [
        {
          text: "Потоком документа HTML називається порядок виведення елементів на сторінку. У звичайному вигляді всі блоки виводяться у порядку, у якому записані всередині HTML-документа. Потік можна змінювати за допомогою css правил, наприклад, за допомогою position: absolute.",
          correct: true,
        },
        { text: "Document flow — це окрема JS-бібліотека.", correct: false },
        { text: "Document flow — це CSS-фреймворк.", correct: false },
        { text: "Document flow визначається лише сервером.", correct: false },
      ]
    ),

    makeQuestion(
      "html-8",
      "Якими способами можна підключити JavaScript до HTML-сторінки? У чому різниця між ними?",
      [
        {
          text: "Перший спосіб — вставити скрипт у блок script. Другий спосіб — підключити скрипт за допомогою додавання посилання на файл JavaScript. Бажано всі скрипти підключати наприкінці блоку body; атрибути async (виконується одразу після завантаження) і defer (виконується після парсингу) впливають на завантаження/виконання.",
          correct: true,
        },
        { text: "JS підключається тільки через CSS.", correct: false },
        {
          text: "JS потрібно вставляти лише у <head> без атрибутів.",
          correct: false,
        },
        {
          text: "Тільки браузер Chrome підтримує зовнішні скрипти.",
          correct: false,
        },
      ]
    ),

    makeQuestion(
      "html-9",
      "Якими способами можна додати CSS-стилі до HTML-сторінки? У чому різниця?",
      [
        {
          text: "Перший спосіб — описати селектори та їх значення всередині тегу style. Другий спосіб — підключити стилі за допомогою додавання посилання на зовнішній файл css, використовують тег link, що розташовується всередині блоку head. Третій спосіб — додати інлайнові стилі для кожного окремого елемента, використовуючи атрибут style.",
          correct: true,
        },
        { text: "CSS можна додати лише через <script>.", correct: false },
        { text: "CSS додається тільки з сервера, через JSON.", correct: false },
        { text: "Немає різниці між усіма способами.", correct: false },
      ]
    ),

    makeQuestion(
      "html-10",
      "У чому різниця між файлами reset.css і normalize.css? Для чого їх використовують?",
      [
        {
          text: "reset.css - скидає всі стилі в нуль для того, щоб можна було розпочати стилізацію сайту з чистого аркуша. normalize.css - приводить вихідні стилі до єдиного стану, у всіх браузерах.",
          correct: true,
        },
        {
          text: "reset.css робить сайт адаптивним, normalize.css — ні.",
          correct: false,
        },
        { text: "normalize.css — бібліотека JS.", correct: false },
        {
          text: "reset.css додає нові кольори за замовчуванням.",
          correct: false,
        },
      ]
    ),

    makeQuestion(
      "css-1",
      "У чому різниця між margin та padding у CSS? Як кожна властивість впливає на елемент?",
      [
        {
          text: "margin — зовнішній відступ (між елементами), padding — внутрішній відступ (всередині елемента, між вмістом і border).",
          correct: true,
        },
        { text: "padding змінює колір фону, margin — шрифт.", correct: false },
        { text: "margin — внутрішній, padding — зовнішній.", correct: false },
        { text: "margin та padding — однакові властивості.", correct: false },
      ]
    ),

    makeQuestion(
      "css-2",
      "Що таке специфічність (specificity) CSS-селекторів і як вона впливає на застосування стилів?",
      [
        {
          text: "Це спосіб, за допомогою якого браузери визначають, які значення властивостей CSS найбільше відповідають елементу і, отже, будуть застосовані.  Специфічність є вагою, що надається конкретному правилу CSS. Найбільшу вагу мають inline стилі. Потім стилі селектора за ID. Найменшу вагу мають селектори по тегу і також селектор*.",
          correct: true,
        },
        {
          text: "Specificity — властивість, що задає прозорість елемента.",
          correct: false,
        },
        {
          text: "Specificity застосовується тільки до шрифтів.",
          correct: false,
        },
        { text: "Specificity — JS-функція для стилів.", correct: false },
      ]
    ),

    makeQuestion(
      "css-3",
      "У чому різниця між псевдокласом і псевдоелементом у CSS? Наведіть приклади.",
      [
        {
          text: "Псевдокласи описують особливий стан елементу. Наприклад, стан натиснутої кнопки. Псевдоелементи відповідають віртуальним елементам. Наприклад, потрібно виділити першу літеру в рядку.",
          correct: true,
        },
        {
          text: "Псевдоклас — це старий синтаксис для псевдоелементів.",
          correct: false,
        },
        {
          text: "Псевдоелементи застосовуються тільки до <img>.",
          correct: false,
        },
        { text: "Псевдокласи змінюють HTML-тег.", correct: false },
      ]
    ),

    makeQuestion(
      "css-4",
      "Що таке блочна модель (box model) у CSS і з яких частин вона складається?",
      [
        {
          text: "Кожен блок має прямокутну область вмісту в центрі, поля навколо вмісту (padding), рамку навколо полів (border) та відступ за межами рамки (margin).",
          correct: true,
        },
        { text: "Box model — це лише margin і padding.", correct: false },
        { text: "Box model — це JS-обʼєкт для CSS.", correct: false },
        { text: "Box model визначає виключно кольори рамок.", correct: false },
      ]
    ),

    makeQuestion(
      "css-5",
      "Яку роль відіграє властивість box-sizing у CSS і як вона впливає на обчислення розмірів елементів?",
      [
        {
          text: "Властивість box-sizing визначає як бчислюється загальна ширина та висота елемента. Має 2 поведінки: - content-box це стандартна поведінка. Якщо встановити елементу ширину 100 пікселів, то ширина його контенту буде 100 пікселів, а ширина меж і внутрішніх відступів під час рендеру буде додана до фінальної ширини, що зробить елемент ширше ста пікселів. - border-box каже браузеру враховувати будь-які межі та внутрішні відступи у значеннях, які вказані у ширині та висоті елемента. Якщо виставити елементу ширину 100 пікселів, то ці 100 пікселів будуть містити межі та внутрішні відступи, а контент стискається, щоб виділити для них місце. Зазвичай це полегшує роботу з розмірами елементів.",
          correct: true,
        },
        { text: "box-sizing змінює розмір шрифту в елементі.", correct: false },
        { text: "box-sizing видаляє margin автоматично.", correct: false },
        { text: "box-sizing — синонім display.", correct: false },
      ]
    ),

    makeQuestion(
      "css-6",
      "Які існують типи позиціонування елементів у CSS і чим вони відрізняються?",
      [
        {
          text: "Існує 5 видів позиціонування: - static - тандартне позиціонування; - relative - позиціонування щодо самого себе; - absolute - позиціонування щодо його найближчого відносно позиціонованого предка, якщо такий є; - fixed - позиціонування відносно viewport - sticky - липке позиціонування, яке може змінювати своє значення з relative на fixed під час прокручування сторінки. ",
          correct: true,
        },
        {
          text: "left, right, top, bottom — типи позиціонування.",
          correct: false,
        },
        {
          text: "position — тільки для блоків, не для inline.",
          correct: false,
        },
        { text: "position — це метод JS.", correct: false },
      ]
    ),

    makeQuestion(
      "css-7",
      "За що відповідає властивість z-index у CSS і коли її використовують?",
      [
        {
          text: "Ця властивість визначає положення елемента та елементів, розташованих нижче по осі z. У разі перекриття елементів це значення визначає порядок накладання. У загальному випадку елементи з більшим z-index перекривають елементи з меншим. Ця властивість працює тільки для елементів, у яких значення position встановлено як absolute, fixed або relative.",
          correct: true,
        },
        { text: "z-index задає прозорість елементу.", correct: false },
        { text: "z-index задає товщину бордера.", correct: false },
        { text: "z-index впливає на розмір шрифту.", correct: false },
      ]
    ),

    makeQuestion(
      "css-8",
      "Як працює абсолютне позиціонування (position: absolute) у CSS і відносно чого розміщується елемент?",
      [
        {
          text: "Абсолютно позиціонований елемент позиціонується щодо його найближчого відносно позиціонованого предка, якщо такий є; якщо такого немає — відносно body.",
          correct: true,
        },
        {
          text: "Absolute завжди позиціонується відносно viewport незалежно від предків.",
          correct: false,
        },
        {
          text: "Absolute змушує елемент залишатися в потоці документа.",
          correct: false,
        },
        { text: "Absolute автоматично робить елемент інлайн.", correct: false },
      ]
    ),

    makeQuestion(
      "css-9",
      "Що таке гумова (fluid), адаптивна (adaptive) та відзивчива (responsive) верстка? У чому між ними різниця?",
      [
        {
          text: "У гумовій верстці блоки змінюють ширину залежно від розміру вікна браузера. Адаптивна верстка реалізується за допомогою правил @media. Це дає змогу для кожного окремого розміру екрана відображати різну верстку. Будь-яка зміна розміру вікна відбувається ривками, після досягнення однієї із зазначених точок перелому. Респонсивна верстка — це поєднання гумової та адаптивної верстки. У реалізації найскладніша. Але результат виходить найбільш прийнятним.",
          correct: true,
        },
        {
          text: "Responsive означає, що макет завжди фіксований.",
          correct: false,
        },
        { text: "Adaptive — це лише для мобільних браузерів.", correct: false },
        { text: "Fluid — використовує лише px.", correct: false },
      ]
    ),

    makeQuestion(
      "css-10",
      "У чому різниця між visibility: hidden і display: none у CSS?",
      [
        {
          text: "visibility:hidden залишає елемент у нормальному потоці сторінки, і він все ще займає місце. display:none видаляє елемент із нормального потоку сторінки, що дозволяє іншим елементам заповнити його місце. ",
          correct: true,
        },
        { text: "visibility: hidden видаляє елемент з DOM.", correct: false },
        { text: "display: none робить елемент напівпрозорим.", correct: false },
        { text: "Немає різниці між ними.", correct: false },
      ]
    ),

    makeQuestion(
      "css-11",
      "Що таке властивість transition у CSS і як вона працює? Наведіть приклад.",
      [
        {
          text: "transition задає плавний перехід зміни властивостей (наприклад: transition: background-color 0.3s ease;).",
          correct: true,
        },
        { text: "transition — це JS-функція для анімації.", correct: false },
        { text: "transition працює тільки з transform.", correct: false },
        { text: "transition обовʼязково виконується миттєво.", correct: false },
      ]
    ),

    makeQuestion(
      "html-11",
      "У чому різниця між відносною (relative) та абсолютною (absolute) адресою в HTML? Коли яку краще використовувати?",
      [
        {
          text: "Абсолютні адреси повинні починатися із зазначення протоколу (зазвичай http://) та містити ім'я сайту. (http://some-site.com/path) Відносні посилання ведуть відлік від кореня сайту чи поточного документа. (/path)",
          correct: true,
        },
        {
          text: "Відносна адреса завжди починається з https://",
          correct: false,
        },
        {
          text: "Абсолютна адреса працює тільки для локальних файлів.",
          correct: false,
        },
        { text: "Немає практичної різниці між ними.", correct: false },
      ]
    ),

    makeQuestion("html-12", "У чому різниця між тегом і елементом в HTML?", [
      {
        text: "Теги використовують для позначення початку та кінця вмісту HTML елемента. Елемент складається з тегів та вмісту.",
        correct: true,
      },
      { text: "Тег — це те саме, що CSS-клас.", correct: false },
      { text: "Елемент — це лише текст в документі.", correct: false },
      { text: "Немає жодної різниці між тегом і елементом.", correct: false },
    ]),

    makeQuestion(
      "html-13",
      "У яких випадках слід використовувати тег <button>, а в яких — <a>? У чому між ними різниця?",
      [
        {
          text: "Кнопка — це функціональний елемент, тобто елемент, який відповідає за виконання певної функції після натискання на неї. Посилання — це елемент навігації, тобто елемент, який відповідає за взаємозв'язок розділів веб-ресурсу (або різних ресурсів) між собою.",
          correct: true,
        },
        {
          text: "<a> завжди краще, ніж <button> для всякої взаємодії.",
          correct: false,
        },
        { text: "<button> не можна стилізувати через CSS.", correct: false },
        { text: "<a> не підтримується в мобільних браузерах.", correct: false },
      ]
    ),

    makeQuestion(
      "html-14",
      "Навіщо потрібен атрибут type у тега <button> і які значення він може мати?",
      [
        {
          text: "type визначає тип кнопки, який встановлює її поведінку у формі. На вигляд кнопки різного типу ніяк не відрізняються, але у кожної такої кнопки свої функції. Існує 3 типи: button, reset і submit. За замовчуванням встановлено значення submit.",
          correct: true,
        },
        { text: "type задає кольорову тему для кнопки.", correct: false },
        { text: "type визначає розмір шрифту кнопки.", correct: false },
        {
          text: "Атрибут type є застарілим і не використовується.",
          correct: false,
        },
      ]
    ),

    makeQuestion(
      "html-15",
      "У чому різниця між елементами форми checkbox і radio? Коли який варто використовувати?",
      [
        {
          text: "radio - створює перемикання між варіантами та дозволяє вибрати тільки один з них. checkbox - застосовується у формі для вибору кількох значень.",
          correct: true,
        },
        {
          text: "Radio дозволяє множинний вибір, checkbox — один.",
          correct: false,
        },
        {
          text: "Checkbox завжди відправляє форму, radio — ні.",
          correct: false,
        },
        { text: "Radio працює лише в IE.", correct: false },
      ]
    ),

    makeQuestion(
      "html-16",
      "Що таке наслідування стилів у CSS і як воно працює? Що таке каскадність?",
      [
        {
          text: "Коли вказується стиль елемента, частина властивостей може бути успадкована його дочірніми елементами та нащадками. Наприклад, якщо задати колір тексту для body, то всі дочірні елементи та нащадки його успадкують.",
          correct: true,
        },
        {
          text: "Наслідування змінює HTML-структуру, каскадність — це тип шрифту.",
          correct: false,
        },
        {
          text: "Наслідування означає копіювання всіх стилів у всі елементи.",
          correct: false,
        },
        {
          text: "Каскадність — це властивість, що задає висоту елемента.",
          correct: false,
        },
      ]
    ),

    makeQuestion(
      "html-17",
      "У чому різниця між контентними зображеннями та фоновими? Коли використовувати <img>, а коли background-image?",
      [
        {
          text: "За допомогою контентних зображень до користувачів доноситься корисна інформація. Щоб додати контентне зображення на сторінку, в розмітці використовується тег <img>. Для таких зображень необхідно заповнювати атрибут alt, який описує те, що зображено на картинці. background-image — для фонових зображень використовується виключно для оформлення. Такі зображення не несуть для користувача корисну інформацію. Їх слід реалізовувати за допомогою CSS.",
          correct: true,
        },
        { text: "background-image кращий для SEO, ніж <img>.", correct: false },
        { text: "<img> не працює на мобільних.", correct: false },
        {
          text: "Нема різниці — завжди краще background-image.",
          correct: false,
        },
      ]
    ),

    makeQuestion(
      "html-18",
      "Чому елементи <img> та <input> не підтримують псевдоелементи ::before і ::after?",
      [
        {
          text: "Псевдоелементи ::before та ::after дають результат тільки для тих елементів, які мають вміст. А у <img> та <input> вмісту немає.",
          correct: true,
        },
        {
          text: "Тому що браузери забороняють стилі для <img> і <input>.",
          correct: false,
        },
        {
          text: "Псевдоелементи працюють тільки з тегом <div>.",
          correct: false,
        },
        { text: "Це залежить від кольору фону сторінки.", correct: false },
      ]
    ),

    makeQuestion(
      "css-12",
      "Навіщо в CSS використовується функція calc() і в яких випадках вона корисна?",
      [
        {
          text: "Функція calc дозволяє розрахувати значення властивостей CSS під час їх визначення. Вона приймає як параметр математичний вираз, результат обчислення якого можна використовувати як значення CSS властивості.",
          correct: true,
        },
        {
          text: "calc() — це JS-функція, що викликається в CSS.",
          correct: false,
        },
        {
          text: "calc() автоматично робить елемент адаптивним.",
          correct: false,
        },
        { text: "calc() змінює шрифт елемента.", correct: false },
      ]
    ),

    makeQuestion(
      "css-13",
      "Що таке flex-контейнер і flex-елементи в CSS? Як вони взаємодіють?",
      [
        {
          text: "Flex-контейнер встановлює новий гнучкий контекст форматування для його вмісту. Flex-контейнером є той елемент, у якого задано властивість display: flex або display: inline-flex. Flex-елементом є кожен дочірній елемент flex-контейнера.",
          correct: true,
        },
        { text: "Flex — це бібліотека для роботи зі стилями.", correct: false },
        {
          text: "Flex автоматично додає margin усім елементам.",
          correct: false,
        },
        { text: "Flex призначений тільки для колонок меню.", correct: false },
      ]
    ),

    makeQuestion(
      "css-14",
      "Що таке flex-вісь у CSS Flexbox і як вона впливає на розташування елементів?",
      [
        {
          text: "Flexbox визначає поняття головної та допоміжної осі. Елементи flex завжди розміщуються вздовж головної осі. При цьому головна вісь може бути розташована горизонтально чи вертикально. Спочатку головна вісь розташована горизонтально з напрямком елементів справа наліво. Напрямок головної осі можна змінити за допомогою властивості flex-direction.",
          correct: true,
        },
        { text: "Flex-вісь — це фізична вісь у 3D-просторі.", correct: false },
        { text: "Flex-вісь залежить від z-index.", correct: false },
        { text: "Flex-вісь доступна тільки в Firefox.", correct: false },
      ]
    ),

    makeQuestion(
      "css-15",
      "У чому різниця між підходами mobile first і desktop first у веброзробці? Який сучасніший і чому?",
      [
        {
          text: "Mobile first орієнтований на вузькі екрани. Це підхід, коли стилі застосовуються спочатку до мобільних пристроїв. Розширені стилі та інші перевизначення для великих екранів потім додаються до таблиці стилів через медіазапити. Desktop first орієнтований на широкі екрани. Це підхід, при якому стилі застосовуються спочатку до великих пристроїв. Розширені стилі та перевизначення для менших екранів потім додаються до таблиці стилів через медіазапити.",
          correct: true,
        },
        {
          text: "Desktop-first означає, що сайт не буде працювати на мобільних.",
          correct: false,
        },
        {
          text: "Mobile-first означає, що немає адаптивності.",
          correct: false,
        },
        { text: "Нема різниці — обидва підходи застарілі.", correct: false },
      ]
    ),

    makeQuestion(
      "css-16",
      "Які переваги має формат SVG порівняно з PNG або JPEG? У яких випадках краще використовувати SVG?",
      [
        {
          text: "1 - На відміну від растрової графіки, SVG не втрачає якості при масштабуванні. 2 - Браузеру не потрібно запитувати картинку у сервера, оскільки він сам її малює, отже, продуктивність підвищується. 3 - За допомогою CSS/JS можна змінювати параметри графіки на сайті, наприклад, фон, прозорість або межі. Також SVG можна анімувати. 4 - Об'єкти SVG важать набагато менше растрових зображень.",
          correct: true,
        },
        { text: "SVG завжди важчий за PNG.", correct: false },
        { text: "SVG не працює в мобільних браузерах.", correct: false },
        { text: "SVG — растровий формат для фотографій.", correct: false },
      ]
    ),

    makeQuestion(
      "css-17",
      "У чому різниця між форматами кольору rgb, rgba та hex у CSS? Коли який краще використовувати?",
      [
        {
          text: "rgb - це змішування червоного, зеленого та синього кольору у відсотковому чи числовому співвідношенні для отримання потрібного кольору. rgba - це той же rgb тільки з альфа-каналом, який задає рівень непрозорості (0 – прозорий, 1 – непрозорий). hex - цей опис кольору заснований на 16-річному записі числа. ",
          correct: true,
        },
        { text: "hex не підтримується в сучасних браузерах.", correct: false },
        { text: "rgb — тільки для фонів, rgba — для тексту.", correct: false },
        { text: "rgba — це формат аудіо.", correct: false },
      ]
    ),

    makeQuestion(
      "css-18",
      "Що таке @media в CSS і як працюють медіа-запити? Наведіть приклад.",
      [
        {
          text: "Медіа-запити дозволяють застосовувати стилі залежно від характеристик пристрою (наприклад @media (max-width: 600px) { ... }).",
          correct: true,
        },
        {
          text: "@media — це JS-хук для прослуховування подій.",
          correct: false,
        },
        { text: "@media змінює HTML-структуру автоматично.", correct: false },
        { text: "@media — синонім до CSS-перемінної.", correct: false },
      ]
    ),
    makeQuestion(
      "css-19",
      "43. Чим відрізняється лінійний та радіальний градієнти?",
      [
        {
          text: "Лінійний градієнт створюється за допомогою двох і більше кольорів, для яких задано напрямок розподілу. Якщо напрямок не вказано, використовується значення за замовчуванням — зверху-вниз. Радіальний градієнт відрізняється від лінійного тим, що кольори виходять із центру градієнта і рівномірно розподіляються назовні, набуваючи форми кола.",
          correct: true,
        },
        {
          text: "Лінійний і радіальний градієнти не мають відмінностей — це однакові ефекти, які відрізняються лише назвою.",
          correct: false,
        },
        {
          text: "Лінійний градієнт завжди має форму кола, а радіальний — прямої лінії з фіксованим напрямком.",
          correct: false,
        },
        {
          text: "Радіальний градієнт можна створити лише з двох кольорів, тоді як лінійний підтримує необмежену кількість кольорів.",
          correct: false,
        },
      ]
    ),
  ],

  js: [
    makeQuestion(
      "js-1",
      "Які типи даних існують у JavaScript? Наведіть приклади.",
      [
        {
          text: "У JavaScript існують примітивні типи даних: string, number, boolean, null, undefined. Наприклад: 'text', 10, true, null, undefined",
          correct: true,
        },
        {
          text: "char, integer, double — стандартні типи JavaScript.",
          correct: false,
        },
        {
          text: "only string and number — JS має лише два типи.",
          correct: false,
        },
        {
          text: "float, real — типи, які використовуються в JS.",
          correct: false,
        },
      ]
    ),

    makeQuestion("js-2", "Що таке NaN і в яких випадках він зʼявляється?", [
      {
        text: "Якщо неможливо привести значення до числа, результатом перетворення буде спеціальне значення NaN (Not a Number).",
        correct: true,
      },
      { text: "NaN — тип рядка для пустого значення.", correct: false },
      { text: "NaN — це функція Math.NaN().", correct: false },
      { text: "NaN — логічне значення true/false.", correct: false },
    ]),

    makeQuestion("js-3", "У чому різниця між операторами == та ===?", [
      {
        text: "Оператор == (дорівнює) — порівнює два значення на рівність і повертає true, якщо значення операндів рівні. Якщо навпаки, повертає false.  Оператор === (сувора рівність) — порівнює два значення на рівність, повертає true, якщо значення операндів рівні та мають однаковий тип даних. В іншому випадку, повертає false",
        correct: true,
      },
      {
        text: "=== приводить типи до рядка перед порівнянням.",
        correct: false,
      },
      { text: "== завжди точніше за ===.", correct: false },
      { text: "Нема різниці між ними.", correct: false },
    ]),

    makeQuestion("js-4", "У чому різниця між null та undefined?", [
      {
        text: "undefined — значення не ініціалізоване; null — явне призначення відсутності значення.",
        correct: true,
      },
      { text: "null — це 0 в JS.", correct: false },
      { text: "undefined — означає помилку в коді завжди.", correct: false },
      { text: "null і undefined — однакові поняття.", correct: false },
    ]),

    makeQuestion("js-5", "Як працюють логічні оператори !, && та ||?", [
      {
        text: "Оператор ! інвертує логічне значення (true → false, false → true). Оператор && повертає перше значення, яке приводиться до false, або останнє значення, якщо всі істинні. Оператор || повертає перше значення, яке приводиться до true, або останнє значення, якщо всі хибні.",
        correct: true,
      },
      {
        text: "&& і || завжди повертають true або false (булеві значення).",
        correct: false,
      },
      { text: "! — знак для коментарів.", correct: false },
      { text: "|| виконує арифметичне додавання.", correct: false },
    ]),

    makeQuestion(
      "js-6",
      "Що таке 'use strict' і для чого його використовують?",
      [
        {
          text: "'use strict' - це спеціальний режим виконання коду, який дає змогу переводити скрипт у режим повної відповідності сучасному стандарту. Це запобігає певним помилкам, наприклад, використанню небезпечних і застарілих конструкцій, що робить код надійнішим та дозволяє легше його підтримувати.",
          correct: true,
        },
        { text: "Це назва бібліотеки для роботи з рядками.", correct: false },
        {
          text: "'use strict' — CSS-правило для строгих шрифтів.",
          correct: false,
        },
        { text: "Це функція для оптимізації продуктивності.", correct: false },
      ]
    ),

    makeQuestion(
      "js-7",
      "У чому різниця між <script>, <script async> та <script defer>?",
      [
        {
          text: "1 - Коли браузер завантажує HTML і доходить до тегу <script>, він призупиняє будувати DOM. Він повинен спочатку завантажити та виконати скрипт, і лише потім обробити решту сторінки. 2 - Атрибут async повідомляє браузеру, що він повинен продовжувати обробляти сторінку та завантажувати скрипт у фоновому режимі, а потім запустити цей скрипт, як тільки він буде завантажений. 3 - Атрибут defer повідомляє браузеру, що він повинен продовжувати обробляти сторінку та завантажувати скрипт у фоновому режимі, а потім запустити цей скрипт, коли сторінка завантажилася.",
          correct: true,
        },
        { text: "async виконується після defer завжди.", correct: false },
        { text: "defer працює тільки у Firefox.", correct: false },
        { text: "Нема різниці між ними.", correct: false },
      ]
    ),

    makeQuestion(
      "js-8",
      "Чому порівняння двох однакових на вигляд об'єктів дає false?",
      [
        {
          text: "Обʼєкти порівнюються за посиланням; два різні обʼєкти навіть з однаковими полями мають різні посилання.",
          correct: true,
        },
        { text: "Тому що обʼєкти не можна порівнювати у JS.", correct: false },
        {
          text: "JS помилково повертає false для всіх обʼєктів.",
          correct: false,
        },
        {
          text: "Потрібно використовувати оператор === для порівняння обʼєктів.",
          correct: false,
        },
      ]
    ),

    makeQuestion(
      "js-9",
      "Як працює метод filter у масивах? Наведіть приклад його використання.",
      [
        {
          text: "Метод filter використовується для фільтрації масиву. Під фільтрацією масиву мається на увазі відбір усіх елементів з колекції за певним критерієм. Повертає новий масив,додає в масив елементи, які задовольняють умову колбек-функції. Якщо true то додає ,якщо false то не додає.Приклад: .filter(value => value >= 0);",
          correct: true,
        },
        { text: "filter змінює оригінальний масив на місці.", correct: false },
        {
          text: "filter повертає число — кількість елементів.",
          correct: false,
        },
        { text: "filter — це метод лише для рядків.", correct: false },
      ]
    ),

    makeQuestion(
      "js-10",
      "Що таке слухач подій (event listener) і як його додати до елемента у JavaScript?",
      [
        {
          text: "Event listener — функція, що виконується при події; додається через element.addEventListener(event, handler, options). Де event — рядок, що містить ім'я події, наприклад (click),  handler — колбек-функція, яка буде викликана під час настання події та options — необов'язковий об'єкт параметрів із розширеними налаштуваннями.",
          correct: true,
        },
        { text: "Event listener — CSS-псевдоклас :event.", correct: false },
        {
          text: "Event listener додається через HTML-коментарі.",
          correct: false,
        },
        { text: "Event listener — це метод для масивів.", correct: false },
      ]
    ),

    makeQuestion("js-11", "У чому різниця між змінними var, let і const?", [
      {
        text: "var дозволяє повторне оголошення змінної і є застарілим синтаксисом; const не дозволяє переприсвоювати значення змінної, тоді як let дозволяє.",
        correct: true,
      },
      { text: "var — блочна область, let — глобальна.", correct: false },
      { text: "const можна переприсвоювати як var.", correct: false },
      { text: "Нема різниці між ними.", correct: false },
    ]),

    makeQuestion(
      "js-12",
      "Як перевірити, чи є дані масивом? Наведіть приклад.",
      [
        { text: "Array.isArray(value) — найнадійніший спосіб.", correct: true },
        {
          text: "typeof value === 'array' — правильний спосіб.",
          correct: false,
        },
        {
          text: "value.isArray() — вбудований метод для всіх типів.",
          correct: false,
        },
        {
          text: "value instanceof 'Array' — стандартний спосіб.",
          correct: false,
        },
      ]
    ),

    makeQuestion("js-13", "Які перебираючі методи масивів ви знаєте?", [
      {
        text: "forEach (виконує функцію для кожного елемента; не створює новий масив, але можна змінити оригінальні елементи), map (повертає новий масив, не змінює оригінал), flatMap (map + flatten, повертає новий масив), filter (повертає новий масив з елементами, що задовольняють умову), find (повертає перший елемент, що задовольняє умову), every (перевіряє, чи всі елементи задовольняють умову, повертає boolean), some (перевіряє, чи хоча б один елемент задовольняє умову, повертає boolean), reduce (акумулює значення в одне, повертає будь-яке значення), toSorted (повертає новий відсортований масив, не змінює оригінал).",
        correct: true,
      },
      { text: "iterate, loop — офіційні методи JS.", correct: false },
      { text: "map і filter — тільки в Python.", correct: false },
      { text: "forIn — рекомендований метод для масивів.", correct: false },
    ]),

    makeQuestion("js-14", "Як можна об'єднати кілька масивів?", [
      {
        text: "Через concat або оператор spread: [...firstArray, ...secondArray]. Обидва способи створюють новий масив, вихідні масиви залишаються незмінними.",
        correct: true,
      },
      { text: "addArrays(a,b) — вбудована функція JS.", correct: false },
      { text: "Обʼєднання масивів неможливе у JS.", correct: false },
      { text: "Використовувати JSON.stringify для злиття.", correct: false },
    ]),

    makeQuestion("js-15", "Як перевірити, чи містить масив певний елемент?", [
      {
        text: "За допомогою includes(value) або some(callback), які повертають true або false.",
        correct: true,
      },
      { text: "typeof array === 'contains'.", correct: false },
      { text: "array.has(value) — вбудований метод.", correct: false },
      { text: "Перевірити через for...in — завжди правильно.", correct: false },
    ]),

    makeQuestion(
      "js-16",
      "Чи можна використовувати цикл for...in для масивів? Які недоліки такого підходу?",
      [
        {
          text: "Можна, але небажано — for...in ітерує ключі (включно з наслідуваними) і може давати непередбачувані результати.",
          correct: true,
        },
        {
          text: "for...in — кращий підхід для масивів ніж forEach.",
          correct: false,
        },
        { text: "for...in не працює в сучасних браузерах.", correct: false },
        { text: "for...in автоматично сортує масив.", correct: false },
      ]
    ),

    makeQuestion("js-17", "Що таке підняття (hoisting) і як воно працює?", [
      {
        text: "Hoisting — підняття оголошень (var, function) на початок області видимості; let/const теж піднімаються, але в TDZ. TDZ — це тимчасова зона, де змінна let або const існує, але ще не ініціалізована, і доступ до неї до оголошення викликає ReferenceError",
        correct: true,
      },
      { text: "Hoisting — процес зменшення розміру файлу.", correct: false },
      { text: "Hoisting — новий синтаксис для функцій.", correct: false },
      { text: "Hoisting тільки в браузері Safari.", correct: false },
    ]),

    makeQuestion(
      "js-18",
      "Яким буде значення змінної, оголошеної через var, якщо звернутися до неї до оголошення?",
      [
        {
          text: "undefined — через hoisting оголошення піднімається без ініціалізації.",
          correct: true,
        },
        { text: "Отримаєш ReferenceError.", correct: false },
        { text: "Отримаєш null.", correct: false },
        { text: "Значення буде NaN.", correct: false },
      ]
    ),

    makeQuestion(
      "js-19",
      "Що станеться, якщо звернутися до змінної, оголошеної через let або const, до її оголошення?",
      [
        {
          text: "Отримаєш ReferenceError через Temporal Dead Zone (TDZ).",
          correct: true,
        },
        { text: "Повернеться undefined, як з var.", correct: false },
        { text: "Повернеться null.", correct: false },
        { text: "JS автоматично ініціалізує її нулем.", correct: false },
      ]
    ),

    makeQuestion(
      "js-20",
      "Що таке область видимості (scope) і які її види існують?",
      [
        {
          text: "Область видимості (scope) — механізм, який визначає доступність змінних у коді, що виконується. Ланцюжок областей видимості (scope chain) — області видимості утворюють ієрархію, так що дочірні області мають доступ до змінних із батьківських областей, але не навпаки. Змінна видима для виконуваного коду, якщо вона є:в поточній області видимості або в ланцюжку областей видимості.",
          correct: true,
        },
        { text: "Scope — тільки глобальні змінні.", correct: false },
        { text: "Scope — це тип функції.", correct: false },
        { text: "Scope — це тільки в браузері.", correct: false },
      ]
    ),

    makeQuestion(
      "js-21",
      "У чому різниця між Function Declaration та Function Expression?",
      [
        {
          text: "Function Declaration оголошується окремою конструкцією і може бути викликана до місця оголошення завдяки hoisting. Function Expression — це функція, присвоєна змінній (наприклад, const), і її можна викликати лише після оголошення, оскільки вона не доступна до ініціалізації змінної.",
          correct: true,
        },
        { text: "Declaration — це завжди стрілкова функція.", correct: false },
        { text: "Expression — це тип класу.", correct: false },
        { text: "Немає між ними різниці.", correct: false },
      ]
    ),

    makeQuestion(
      "js-22",
      "Що таке callback-функція і навіщо її використовують?",
      [
        {
          text: "Callback-функція — це функція, яка передається як аргумент в іншу функцію і викликається всередині неї для обробки результату, події або виконання певної дії. Це дозволяє робити код гнучким і повторно використовуваним.",
          correct: true,
        },
        { text: "Callback — функція, яка повертає проміс.", correct: false },
        { text: "Callback — це особливий тип змінної.", correct: false },
        {
          text: "Callback неможливо використовувати в браузері.",
          correct: false,
        },
      ]
    ),

    makeQuestion(
      "js-23",
      "У чому відмінності між стрілковою функцією та звичайною функцією?",
      [
        {
          text: "Стрілкова функція має коротший синтаксис, не має власного this та arguments, створюється лише як function expression і не може використовуватися як конструктор (з new).",
          correct: true,
        },
        { text: "Стрілкові функції завжди працюють швидше.", correct: false },
        { text: "Стрілкові можуть бути лише асинхронними.", correct: false },
        { text: "Нема різниці між ними.", correct: false },
      ]
    ),

    makeQuestion(
      "js-24",
      "Чи мають стрілкові функції доступ до arguments? Якщо ні — який аналог?",
      [
        {
          text: "У стрілочних функцій немає локальної змінної arguments, що містить усі аргументи. Якщо необхідно зібрати всі аргументи в масив, використовується операція rest",
          correct: true,
        },
        { text: "Так, вони завжди мають доступ до arguments.", correct: false },
        { text: "arguments — це тип даних ES6.", correct: false },
        {
          text: "Стрілкові мають arguments як перший параметр.",
          correct: false,
        },
      ]
    ),

    makeQuestion(
      "js-25",
      "Як викликати функцію з затримкою 10 секунд? Наведіть приклад.",
      [
        {
          text: "setTimeout(() => {}, 10000) — виконає fn через 10 секунд.",
          correct: true,
        },
        { text: "sleep(10000) — вбудована функція JS.", correct: false },
        { text: "delay(fn, 10) — стандартний API.", correct: false },
        {
          text: "setInterval(fn, 10) — виконає через 10 секунд.",
          correct: false,
        },
      ]
    ),

    makeQuestion(
      "js-26",
      "Що таке замикання (closure) і для чого його використовують?",
      [
        {
          text: "Closure — функція з доступом до змінних зовнішньої лексичної області навіть після завершення зовнішньої функції; використовується для інкапсуляції стану.",
          correct: true,
        },
        {
          text: "Closure — це коли закривається браузерна вкладка.",
          correct: false,
        },
        { text: "Closure — це новий синтаксис класів.", correct: false },
        { text: "Closure — метод масиву.", correct: false },
      ]
    ),

    makeQuestion(
      "js-27",
      "Які основні принципи обʼєктно-орієнтованого програмування (ООП)?",
      [
        {
          text: "Інкапсуляція, наслідування, поліморфізм, абстракція — основні принципи ООП.",
          correct: true,
        },
        {
          text: "Операції add, remove — основні принципи ООП.",
          correct: false,
        },
        { text: "ООП означає тільки використання функцій.", correct: false },
        {
          text: "ООП — це синонім до функціонального програмування.",
          correct: false,
        },
      ]
    ),

    makeQuestion("js-28", "Що таке this і як визначається його значення?", [
      {
        text: "this — контекст виклику; визначається способом виклику функції (метод, звичайний виклик, new, bind/call/apply).",
        correct: true,
      },
      { text: "this — завжди вказує на глобальний обʼєкт.", correct: false },
      { text: "this — тип даних в JS для рядків.", correct: false },
      { text: "this — синонім до arguments.", correct: false },
    ]),

    makeQuestion(
      "js-29",
      "Якими способами можна змінити контекст (this) під час виклику функції?",
      [
        {
          text: "Через call, apply, bind або виклик через обʼєкт (obj.method()).",
          correct: true,
        },
        {
          text: "Через оператор => (стрілковий) — це змінює this.",
          correct: false,
        },
        { text: "Через створення нового промісу.", correct: false },
        { text: "Не можна змінити контекст у JS.", correct: false },
      ]
    ),

    makeQuestion("js-30", "Що таке прототип об'єкта і яку роль він відіграє?", [
      {
        text: "Прототип — обʼєкт, від якого успадковуються властивості; механізм прототипного наслідування в JS.",
        correct: true,
      },
      { text: "Прототип — це лише для типів у TypeScript.", correct: false },
      { text: "Прототип — бібліотека для побудови обʼєктів.", correct: false },
      { text: "Прототип — це HTML-тег.", correct: false },
    ]),
  ],

  react: [
    makeQuestion(
      "react-1",
      "Що таке JSX і як він перетворюється у звичайний JavaScript?",
      [
        {
          text: "JSX — синтаксичне розширення; під час трансформації (Babel) він перетворюється у виклики React.createElement або відповідні функції.",
          correct: true,
        },
        { text: "JSX — це мова стилів для React.", correct: false },
        {
          text: "JSX — це серверна технологія для рендеру HTML.",
          correct: false,
        },
        { text: "JSX — це альтернативний формат JSON.", correct: false },
      ]
    ),

    makeQuestion("react-2", "В чому різниця між state і props?", [
      {
        text: "props — дані, що передаються батьком і є незмінними для компонента; state — локальний стан компонента, що змінюється.",
        correct: true,
      },
      {
        text: "state передається зверху вниз, props — локальний.",
        correct: false,
      },
      { text: "props і state — синоніми.", correct: false },
      {
        text: "state використовується тільки в класових компонентах.",
        correct: false,
      },
    ]),

    makeQuestion(
      "react-3",
      "Для чого потрібен key у списках і як його використовувати?",
      [
        {
          text: "key — унікальний ідентифікатор елемента для допомоги React у реконсиляції; передається як prop при рендері списку.",
          correct: true,
        },
        { text: "key — CSS-клас, що покращує продуктивність.", correct: false },
        { text: "key — метод для сортування елементів.", correct: false },
        {
          text: "key — це тип файлу для збереження компонентів.",
          correct: false,
        },
      ]
    ),

    makeQuestion(
      "react-4",
      "Як працює механізм підняття стану (lifting state up)?",
      [
        {
          text: "Підняття стану — перенесення спільного стану в найближчий спільний батьківський компонент і передача його через props.",
          correct: true,
        },
        {
          text: "Підняття стану — серіалізація стану в localStorage.",
          correct: false,
        },
        {
          text: "Підняття стану — автоматичне синхронізування з сервером.",
          correct: false,
        },
        {
          text: "Підняття стану — метод React для оптимізації.",
          correct: false,
        },
      ]
    ),

    makeQuestion(
      "react-5",
      "Що таке портали (portals) і як їх використовувати?",
      [
        {
          text: "Portals дозволяють рендерити дочірні елементи у DOM-вузол за межами батьківського компонента (ReactDOM.createPortal).",
          correct: true,
        },
        {
          text: "Portals — це новий тип хуку для роботи з формами.",
          correct: false,
        },
        { text: "Portals — CSS-метод для позиціонування.", correct: false },
        { text: "Portals — компонент для маршрутизації.", correct: false },
      ]
    ),

    makeQuestion(
      "react-6",
      "Що таке refs і коли їх потрібно використовувати?",
      [
        {
          text: "refs дають доступ до DOM-елементів або збережених значень між рендерами (наприклад для фокусу або вимірювань).",
          correct: true,
        },
        { text: "refs — те саме що props.", correct: false },
        {
          text: "refs — глобальна змінна для збереження стану.",
          correct: false,
        },
        { text: "refs — властивість CSS.", correct: false },
      ]
    ),

    makeQuestion(
      "react-7",
      "Що таке контекст (Context API)? Чи може бути кілька контекстів у проєкті?",
      [
        {
          text: "Context дозволяє передавати дані через дерево компонентів без пропс-дрилінгу; у проєкті може бути кілька різних контекстів.",
          correct: true,
        },
        {
          text: "Context — це лише один глобальний обʼєкт в React.",
          correct: false,
        },
        {
          text: "Context — це новий тип хуку тільки для класів.",
          correct: false,
        },
        { text: "Context замінює useState.", correct: false },
      ]
    ),

    makeQuestion(
      "react-8",
      "Які можливості дають хуки? Назвіть кілька прикладів.",
      [
        {
          text: "Хуки дозволяють використовувати стан і побічні ефекти в функціональних компонентах (useState, useEffect, useRef, useMemo, useCallback, useContext, useReducer).",
          correct: true,
        },
        {
          text: "Хуки — це лише синтаксичний цукор для класів.",
          correct: false,
        },
        { text: "Хуки автоматично роблять код синхронним.", correct: false },
        { text: "Хуки — еквівалент CSS-стилів.", correct: false },
      ]
    ),

    makeQuestion("react-9", "Які основні правила використання хуків?", [
      {
        text: "Правила: викликати хуки лише у верхньому рівні компонента і лише з React-функцій (не в циклах чи умовах), дотримуватися порядку викликів.",
        correct: true,
      },
      {
        text: "Хуки можна викликати де завгодно, навіть в циклах.",
        correct: false,
      },
      { text: "Хуки потрібні лише для оптимізації стилів.", correct: false },
      { text: "Хуки автоматично кешуються між компонентами.", correct: false },
    ]),

    makeQuestion(
      "react-10",
      "Для чого потрібен хук useEffect і як уникнути зайвих викликів?",
      [
        {
          text: "useEffect виконує побічні ефекти; уникнути зайвих викликів допомагає вказання масиву залежностей (deps) і правильне управління залежностями.",
          correct: true,
        },
        { text: "useEffect потрібен лише для стилів.", correct: false },
        {
          text: "useEffect виконується тільки один раз завжди.",
          correct: false,
        },
        { text: "useEffect автоматично відміняє всі проміси.", correct: false },
      ]
    ),

    makeQuestion("react-11", "За яких умов компонент оновлюється?", [
      {
        text: "Компонент оновлюється при зміні state або props або при виклику forceUpdate/контексту, що змінюється.",
        correct: true,
      },
      {
        text: "Компонент оновлюється тільки при перезавантаженні сторінки.",
        correct: false,
      },
      {
        text: "Компонент ніколи не оновлюється після першого рендеру.",
        correct: false,
      },
      { text: "Компонент оновлюється тільки при зміні CSS.", correct: false },
    ]),

    makeQuestion(
      "react-12",
      "Як працює однонаправлений потік даних (one-way data flow) у React?",
      [
        {
          text: "Дані тече від батька до дитини через props; дитина не змінює props напряму.",
          correct: true,
        },
        { text: "Дані тече у обидва боки автоматично.", correct: false },
        {
          text: "React використовує двонаправлений binding за замовчуванням.",
          correct: false,
        },
        { text: "One-way flow — це техніка для CSS.", correct: false },
      ]
    ),

    makeQuestion("react-13", "Поясніть патерн контрольованих елементів.", [
      {
        text: "Контрольований елемент — це input, значення якого керується через state компонента; зміни відправляються callback-ом (onChange).",
        correct: true,
      },
      {
        text: "Контрольований елемент — це input без onChange.",
        correct: false,
      },
      {
        text: "Контрольований елемент — це елемент без value.",
        correct: false,
      },
      { text: "Це патерн для роботи з API.", correct: false },
    ]),

    makeQuestion(
      "react-14",
      "Як працює контекст (Context API) і коли його варто використовувати?",
      [
        {
          text: "Context створює провайдера і споживача для передачі значень без пропс-дрилінгу; варто використовувати для теми, автентифікації, локалізації.",
          correct: true,
        },
        { text: "Context замінює всі props в додатку.", correct: false },
        {
          text: "Context автоматично синхронізує дані з сервером.",
          correct: false,
        },
        {
          text: "Context — це тільки для тестування компонентів.",
          correct: false,
        },
      ]
    ),

    makeQuestion(
      "react-15",
      "Як працює React.StrictMode і які переваги його використання?",
      [
        {
          text: "StrictMode — обгортка для виявлення проблем в розробці (дублікатні виклики життєвих циклів у dev), допомагає знайти небезпечні патерни.",
          correct: true,
        },
        { text: "StrictMode прискорює рендер у продакшені.", correct: false },
        { text: "StrictMode потрібен для роботи з CSS.", correct: false },
        { text: "StrictMode — це інструмент для деплою.", correct: false },
      ]
    ),

    makeQuestion(
      "react-16",
      "Для чого використовується TanStack Query? Які її основні можливості?",
      [
        {
          text: "TanStack Query (React Query) спрощує кешування, фетчинг та синхронізацію серверних даних; має кеш, re-fetch, мутації і автоматичне оновлення.",
          correct: true,
        },
        {
          text: "TanStack Query — це бібліотека для стилізації компонентів.",
          correct: false,
        },
        {
          text: "TanStack Query — інструмент для роботи з localStorage.",
          correct: false,
        },
        {
          text: "TanStack Query автоматично перетворює JSX у HTML.",
          correct: false,
        },
      ]
    ),

    makeQuestion(
      "react-17",
      "У чому різниця між useQuery і useMutation у TanStack Query?",
      [
        {
          text: "useQuery використовується для читання/фетчингу (GET); useMutation — для змін (POST/PUT/DELETE) та мутацій.",
          correct: true,
        },
        {
          text: "useQuery робить POST-запити, useMutation — GET.",
          correct: false,
        },
        { text: "Нема різниці між ними.", correct: false },
        { text: "useMutation тільки для кешування.", correct: false },
      ]
    ),

    makeQuestion(
      "react-18",
      "Що таке мемоізація у React (useMemo) і для чого її використовують?",
      [
        {
          text: "useMemo кешує обчислення між рендерами, щоб уникнути дорогих повторних обчислень.",
          correct: true,
        },
        {
          text: "useMemo — метод для кешування API на сервері.",
          correct: false,
        },
        { text: "useMemo автоматично оптимізує CSS.", correct: false },
        { text: "useMemo — синтаксичний цукор для map.", correct: false },
      ]
    ),

    makeQuestion(
      "react-19",
      "Як працюють фрагменти (<React.Fragment>) і для чого вони потрібні?",
      [
        {
          text: "Фрагменти дозволяють групувати дочірні елементи без додаткового DOM-елемента.",
          correct: true,
        },
        { text: "Фрагменти додають додаткові div у DOM.", correct: false },
        {
          text: "Фрагменти — це альтернативний спосіб описати CSS.",
          correct: false,
        },
        { text: "Фрагменти замінюють useState.", correct: false },
      ]
    ),

    makeQuestion(
      "react-20",
      "Як працює процес рендерингу в React? Що таке Virtual DOM, diffing та reconciliation?",
      [
        {
          text: "React рендерить Virtual DOM; при зміні state створюється новий Virtual DOM, React порівнює (diff) з попереднім і оновлює реальний DOM мінімально (reconciliation).",
          correct: true,
        },
        {
          text: "React рендерить HTML на сервері без Virtual DOM.",
          correct: false,
        },
        { text: "diffing — це метод CSS для анімацій.", correct: false },
        {
          text: "reconciliation — бібліотека для маршрутизації.",
          correct: false,
        },
      ]
    ),
  ],

  node: [
    makeQuestion("node-1", "Що таке Node.js і для чого його використовують?", [
      {
        text: "Node.js — середовище виконання JavaScript на сервері (V8) для створення бекенд-застосунків, CLI, інструментів збірки.",
        correct: true,
      },
      { text: "Node.js — це фреймворк для CSS.", correct: false },
      {
        text: "Node.js — це мова програмування, відмінна від JavaScript.",
        correct: false,
      },
      { text: "Node.js — клієнтська бібліотека для браузера.", correct: false },
    ]),

    makeQuestion(
      "node-2",
      "Що таке middleware функція і як її створити в Express?",
      [
        {
          text: "Middleware — функція (req, res, next) що обробляє запит/відповідь; створюється як function (req, res, next) { ... next(); } і підключається через app.use або router.use.",
          correct: true,
        },
        {
          text: "Middleware — CSS-стиль для Express-додатків.",
          correct: false,
        },
        { text: "Middleware — база даних для Express.", correct: false },
        { text: "Middleware — вбудований тип файлів Node.", correct: false },
      ]
    ),

    makeQuestion(
      "node-3",
      "Що таке Mongoose і як він допомагає працювати з MongoDB?",
      [
        {
          text: "Mongoose — ODM-бібліотека для MongoDB, що забезпечує схеми, валідацію і моделі для зручної роботи з документами.",
          correct: true,
        },
        {
          text: "Mongoose — це вбудований драйвер SQL для Node.",
          correct: false,
        },
        { text: "Mongoose — CLI-інструмент для Docker.", correct: false },
        { text: "Mongoose — це шаблон для UI.", correct: false },
      ]
    ),

    makeQuestion("node-4", "Що таке CORS і як його налаштувати в Express?", [
      {
        text: "CORS — механізм контролю доступу між доменами; у Express налаштовують через пакет cors або встановлення заголовків Access-Control-Allow-*.",
        correct: true,
      },
      { text: "CORS — це база даних для Node.", correct: false },
      { text: "CORS — CSS-свойство для стилізації серверів.", correct: false },
      { text: "CORS — інструмент для деплою.", correct: false },
    ]),

    makeQuestion(
      "node-5",
      "Як працюють параметри маршруту і query params в Express?",
      [
        {
          text: "Route params (/:id) отримують значення через req.params; query params (?q=1) доступні через req.query.",
          correct: true,
        },
        { text: "Route params — це заголовки HTTP.", correct: false },
        { text: "Query params — це тільки для POST-запитів.", correct: false },
        {
          text: "Route params і query params обробляються автоматично без доступу в req.",
          correct: false,
        },
      ]
    ),

    makeQuestion("node-6", "Як реалізувати пагінацію у запитах до MongoDB?", [
      {
        text: "Через skip/limit або через cursor-based підхід (limit + lastId) для ефективної пагінації.",
        correct: true,
      },
      { text: "Пагінація в MongoDB не підтримується.", correct: false },
      {
        text: "Потрібно використовувати тільки countDocuments.",
        correct: false,
      },
      {
        text: "Використовувати SQL JOIN для пагінації в MongoDB.",
        correct: false,
      },
    ]),

    makeQuestion("node-7", "Як зберігати і читати cookies у Express?", [
      {
        text: "Через cookie-parser або вручну заголовки Set-Cookie; читати через req.cookies (cookie-parser).",
        correct: true,
      },
      { text: "Cookie зберігаються в базі даних автоматично.", correct: false },
      { text: "Express не працює з cookie.", correct: false },
      {
        text: "Cookie — це тільки для клієнтської JavaScript.",
        correct: false,
      },
    ]),

    makeQuestion(
      "node-8",
      "Як використовувати environment variables у Node.js?",
      [
        {
          text: "Через process.env і часто з бібліотекою dotenv для локальних змінних.",
          correct: true,
        },
        {
          text: "Environment variables зберігаються у package.json.",
          correct: false,
        },
        { text: "Node.js не підтримує environment variables.", correct: false },
        { text: "Environment variables — це властивості CSS.", correct: false },
      ]
    ),

    makeQuestion(
      "node-9",
      "Що таке REST API і як його реалізувати в Express?",
      [
        {
          text: "REST API — архітектурний стиль з ресурсами і HTTP-методами; в Express створюють маршрути (GET/POST/PUT/DELETE) і повертають JSON.",
          correct: true,
        },
        { text: "REST API — це лише для фронтенду.", correct: false },
        { text: "REST API — це база даних.", correct: false },
        { text: "REST API працює лише в браузері.", correct: false },
      ]
    ),

    makeQuestion(
      "node-10",
      "Як створити REST API маршрут для отримання списку ресурсів?",
      [
        {
          text: "Додати маршрут app.get('/items', async (req,res) => { const items = await Model.find(); res.json(items); });",
          correct: true,
        },
        { text: "Створити HTML-сторінку для списку ресурсів.", correct: false },
        { text: "Додати CSS-файл з маршрутом.", correct: false },
        {
          text: "Використати require('list') для отримання ресурсів.",
          correct: false,
        },
      ]
    ),

    makeQuestion(
      "node-11",
      "Як працює маршрутизація в Express і як розбити роутери на модулі?",
      [
        {
          text: "Express використовує middleware і маршрути; роутери створюються через express.Router і імпортуються в основний app.",
          correct: true,
        },
        { text: "Маршрути в Express задаються в CSS-файлах.", correct: false },
        { text: "Розбиття роутерів неможливе.", correct: false },
        { text: "Маршрути створюються через SQL-запити.", correct: false },
      ]
    ),

    makeQuestion(
      "node-12",
      "Як обробляти параметри запиту (query params) і параметри маршруту (route params) у Express?",
      [
        {
          text: "Route params — req.params, query params — req.query; потрібно робити валідацію і санітизацію.",
          correct: true,
        },
        { text: "Обидва — req.body.", correct: false },
        { text: "Query params — це cookie.", correct: false },
        { text: "Route params — це заголовки.", correct: false },
      ]
    ),

    makeQuestion(
      "node-13",
      "Як обробляти файли, що завантажуються, у Express?",
      [
        {
          text: "Через multer або busboy для парсингу multipart/form-data і збереження файлів.",
          correct: true,
        },
        {
          text: "Express автоматично зберігає всі файли на диск.",
          correct: false,
        },
        { text: "Файли не можна обробляти у Node.", correct: false },
        {
          text: "Потрібно використовувати тільки FTP для завантажень.",
          correct: false,
        },
      ]
    ),

    makeQuestion(
      "node-14",
      "Як реалізувати централізовану обробку помилок в Express?",
      [
        {
          text: "Через middleware з чотирма аргументами (err, req, res, next) і виклик next(err) у маршрутах.",
          correct: true,
        },
        { text: "Через CSS правила для сторінок помилок.", correct: false },
        { text: "Через налаштування у package.json.", correct: false },
        { text: "Централізована обробка помилок неможлива.", correct: false },
      ]
    ),

    makeQuestion("node-15", "Як створити модель та схему в Mongoose?", [
      {
        text: "Через mongoose.Schema і mongoose.model('Name', schema) — опис полів і типів, потім використовувати модель для CRUD.",
        correct: true,
      },
      {
        text: "Mongoose автоматично генерує схеми з бази даних.",
        correct: false,
      },
      {
        text: "Моделі в Mongoose створюються через SQL-запити.",
        correct: false,
      },
      { text: "Mongoose — це бібліотека для фронтенду.", correct: false },
    ]),

    makeQuestion(
      "node-16",
      "Як працює валідація даних у Mongoose і де її краще виконувати?",
      [
        {
          text: "Валідація можна задавати в схемі (validators) і також додатково на рівні контролерів/сервісів для безпеки.",
          correct: true,
        },
        {
          text: "Валідація не потрібна, бо MongoDB перевіряє всі дані.",
          correct: false,
        },
        { text: "Валідація виконується лише в браузері.", correct: false },
        { text: "Mongoose не підтримує валідацію.", correct: false },
      ]
    ),

    makeQuestion(
      "node-17",
      "Як реалізувати аутентифікацію користувача в REST API?",
      [
        {
          text: "Через JWT або сесії: перевірка креденшелів, видача токену/сесії і захист маршрутів middleware.",
          correct: true,
        },
        {
          text: "Аутентифікація — це тільки відправка username у заголовку.",
          correct: false,
        },
        {
          text: "Використовувати тільки cookie без будь-яких перевірок.",
          correct: false,
        },
        {
          text: "Аутентифікація не потрібна для приватних API.",
          correct: false,
        },
      ]
    ),

    makeQuestion(
      "node-18",
      "Як захистити маршрути в Express, щоб вони були доступні лише авторизованим користувачам?",
      [
        {
          text: "Додати middleware, що перевіряє токен/сесію і викликає next() тільки при успішній авторизації.",
          correct: true,
        },
        {
          text: "Використати CSS-клас 'protected' на маршрутах.",
          correct: false,
        },
        { text: "Захист маршрутів неможливий у Express.", correct: false },
        { text: "Підключити routes тільки в production.", correct: false },
      ]
    ),

    makeQuestion(
      "node-19",
      "Як працює stream API у Node.js і коли його використовувати?",
      [
        {
          text: "Streams дозволяють обробляти дані частинами (readable/writable) для ефективного читання/запису великих даних.",
          correct: true,
        },
        { text: "Streams — це бібліотека для стилів.", correct: false },
        {
          text: "Streams автоматично кешують всі файли в памʼяті.",
          correct: false,
        },
        { text: "Streams — це окремий процес у Node.", correct: false },
      ]
    ),

    makeQuestion(
      "node-20",
      "Як працює модульна система в Node (require/import) і яка різниця між CommonJS і ES Modules?",
      [
        {
          text: "CommonJS (require/module.exports) — синхронна, ES Modules (import/export) — статична і підтримується сучасними середовищами; синтаксис та завантаження відрізняються.",
          correct: true,
        },
        {
          text: "Нема різниці: require і import повністю однакові.",
          correct: false,
        },
        {
          text: "ES Modules працюють тільки в браузері, а CommonJS — тільки в Node.",
          correct: false,
        },
        { text: "CommonJS — це база даних.", correct: false },
      ]
    ),
  ],
};
